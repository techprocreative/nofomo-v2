export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from 'next/server';
import { LiveTradingService } from '@/lib/services/live-trading-service';
import { StrategyExecutionService } from '@/lib/services/strategy-execution-service';
import { TradingSignal, LiveTradeExecution } from '@/lib/types';
import { withAuth, getUserId } from '@/lib/auth-middleware';

async function handleExecute(request: NextRequest) {
  const { container } = await import('@/lib/di');

  try {
    const userId = getUserId(request as any);
    const body = await request.json();

    const liveTradingService = container.resolve('LiveTradingService') as LiveTradingService;
    const strategyExecutionService = container.resolve('StrategyExecutionService') as StrategyExecutionService;

    // Handle different execution types
    const { type, signal, strategy_id, symbol } = body;

    let execution: LiveTradeExecution;

    if (type === 'signal') {
      // Execute a trading signal directly
      if (!signal) {
        return NextResponse.json(
          { success: false, error: 'Signal data required for signal execution' },
          { status: 400 }
        );
      }

      const tradingSignal: TradingSignal = {
        id: signal.id || `signal_${Date.now()}`,
        strategy_id: signal.strategy_id,
        symbol: signal.symbol,
        type: signal.type || 'entry',
        side: signal.side,
        price: signal.price,
        volume: signal.volume,
        confidence: signal.confidence || 50,
        timestamp: new Date(signal.timestamp) || new Date(),
      };

      execution = await liveTradingService.executeSignal(tradingSignal, userId);

    } else if (type === 'strategy') {
      // Execute strategy to generate and process signals
      if (!strategy_id || !symbol) {
        return NextResponse.json(
          { success: false, error: 'Strategy ID and symbol required for strategy execution' },
          { status: 400 }
        );
      }

      const strategyService = await container.resolve('StrategyService') as any;
      const strategy = await strategyService.getStrategyById(strategy_id);

      if (!strategy || strategy.user_id !== userId) {
        return NextResponse.json(
          { success: false, error: 'Strategy not found or access denied' },
          { status: 404 }
        );
      }

      // Execute strategy to get signals
      const signals = await strategyExecutionService.executeStrategy(strategy, userId, symbol);

      if (signals.length === 0) {
        return NextResponse.json(
          { success: false, error: 'No trading signals generated by strategy' },
          { status: 200 }
        );
      }

      // Execute the first/best signal
      const bestSignal = signals[0]; // Could implement signal ranking
      execution = await liveTradingService.executeSignal(bestSignal, userId);

    } else {
      return NextResponse.json(
        { success: false, error: 'Invalid execution type. Must be "signal" or "strategy"' },
        { status: 400 }
      );
    }

    return NextResponse.json({
      success: true,
      data: execution,
      message: 'Trade executed successfully',
    });

  } catch (error) {
    console.error('Trade execution error:', error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Trade execution failed',
      },
      { status: 500 }
    );
  }
}

async function handleGetExecutions(request: NextRequest) {
  try {
    const userId = getUserId(request as any);

    // Get execution history (simplified - would need proper repository)
    // For now, return empty array
    const executions: LiveTradeExecution[] = [];

    return NextResponse.json({
      success: true,
      data: executions,
    });

  } catch (error) {
    console.error('Get executions error:', error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to get executions',
      },
      { status: 500 }
    );
  }
}

export const POST = withAuth(handleExecute);
export const GET = withAuth(handleGetExecutions);